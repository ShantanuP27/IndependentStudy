# 🚀 MapReduce-Based Quicksort in Hadoop

This project implements a distributed sorting algorithm inspired by **Quicksort** using the **MapReduce programming model** in **Hadoop 3.2.0**. The algorithm explores how the number of **communication rounds** (key-value data shuffles) varies with the number of parallel processes (mappers).

---

## 📌 Features

- Custom input generation with controlled data distribution
- Pivot-based parallel bucketing and sorting
- Tracks total key-value pairs emitted (i.e., communication rounds)
- Supports varying number of mappers (`NUM_MAPPERS`)
- Visualizes communication overhead vs number of processes

---

## ⚙️ Prerequisites

### 1. Java 8 Installation

```bash
sudo apt update
sudo apt install openjdk-8-jdk -y
```

Check version:

```bash
java -version
```

### 2. Hadoop 3.2.0 Installation

```bash
wget https://downloads.apache.org/hadoop/common/hadoop-3.2.0/hadoop-3.2.0.tar.gz
tar -xzf hadoop-3.2.0.tar.gz
mv hadoop-3.2.0 ~/hadoop
```

### 3. Set Environment Variables

Add the following to your `~/.bashrc` or `~/.zshrc`:

```bash
export HADOOP_HOME=~/hadoop
export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin
```

Apply changes:

```bash
source ~/.bashrc
```

---

## 🧾 File Structure

```bash
.
├── input_data/             # Folder containing generated input text file
├── output/                 # Output directory (auto-generated by Hadoop)
├── PivotJob.java           # Mapper + Reducer for pivot selection
├── SortJob.java            # Mapper + Reducer for final sorting
├── QuickSortDriver.java    # Driver class to execute jobs
├── GenerateInput.java      # Random input data generator
├── CountOutput.java        # Utility to count key-value pairs
└── plot.py                 # Python script to plot communication graph
```

---

## 🛠️ How to Run

### Step 1: Compile Java Classes

```bash
mkdir classes
javac -classpath "$HADOOP_HOME/share/hadoop/common/*:$HADOOP_HOME/share/hadoop/mapreduce/*:$HADOOP_HOME/share/hadoop/common/lib/*" -d classes *.java
jar -cvf quicksort.jar -C classes/ .
```

### Step 2: Generate Input File

```bash
hadoop fs -mkdir /input_data
hadoop fs -put input.txt /input_data
```

> Or use the generator:
```bash
java -cp classes GenerateInput <num_elements> <output_filename>
```
> Or the program can directly be run by :
javac -classpath $(hadoop classpath) -d . DistributedSort.java
jar cf DistributedSort.jar DistributedSort*.class
hadoop jar DistributedSort.jar DistributedSort 4000 4
 > where 4000 is number of integers and 4 number of processes
Example:

```bash
java -cp classes GenerateInput 10000 input.txt
hadoop fs -put input.txt /input_data
```

### Step 3: Run the Jobs

```bash
hadoop jar quicksort.jar QuickSortDriver /input_data /output
```

You can modify `NUM_MAPPERS` in `QuickSortDriver.java` to experiment with different process counts.

---

## 📈 Plotting Communication Rounds

The output of communication rounds can be collected and visualized using the included `plot.py`.

```bash
python3 plot.py
```

This will generate a plot showing communication rounds vs number of processes.

---

## 🧠 Observations

- Communication rounds decrease with increased number of mappers.
- Performance gain flattens after a certain number of mappers (~20).
- Demonstrates trade-off between parallelism and coordination overhead.

---

## ✅ Requirements

- Java 8
- Hadoop 3.2.0
- Python 3.6+ (for plotting)
- Matplotlib (install with `pip install matplotlib`)

---

## 📚 References

- [MapReduce Programming Model](https://hadoop.apache.org/)
- [Quicksort Algorithm](https://en.wikipedia.org/wiki/Quicksort)
- Apache Hadoop Documentation

---

## 🧑‍💻 Author

**Your Name**  
*Distributed Systems Enthusiast*

---

## 📄 License

This project is licensed under the MIT License.

